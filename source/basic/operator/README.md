---
author: azu
---

# 演算子

演算子はよく利用する計算を関数やメソッドではなく、記号として表現したものです。
たとえば、足し算を行う `+` も演算子の一種で、演算子には多くの種類があります。

演算子は記号単独ではなく、演算の対象が必要になります。
演算子の対象のことを被演算子（オペランド）と呼ぶ。

次の`1 + 2`という`+`演算子について見てみます。

```js
1 + 2;
```

この演算は、次のような1つの演算子に対して、2つのオペランドを前後に置いています。
このような2つのオペランドを取る演算子を**二項演算子**と呼びます。

```
オペランド1 演算子 オペランド2
```

また、1つの演算子に対して1つのオペランドをとるものもあります。
たとえば、次のような数値をインクリメントする`++`演算子は、前後どちらかにオペランドを置きます。

```js
var num = 1;
num++;
// または
++num;
```

このような1つのオペランドを取る演算子を**単項演算子**と呼びます。
単項演算子と二項演算子で同じ記号を使うことがあり、そのために呼び方を変えています。

多くのプログラミング言語では同じような演算子を持っています。
この節は、分からない記号が出てきたら確認する意味で読むとよいでしょう。

しかし、JavaScriptでは比較演算子において、暗黙的な型変換が行われることによる問題があります。
そのため、演算子をひととおり見た後に、暗黙的な型変換がと明示的な型変換について学んでいきます。

## 二項演算子

四則演算など基本的な二項演算子を見ていきます。


### プラス （`+`）

2つの数値を加算する演算子です。

```js
1 + 1; // => 2
```

### マイナス （`-`）

2つの数値を減算する演算子です。

```js
42 - 1; // => 41
```

### 乗算 （`*`）

2つの数値を乗算する演算子です。

```js
2 * 8; // => 16
```

### 除算 （`/`）

2つの数値を除算する演算子です。

```js
8 / 2; // => 4
```

### 剰余 （`%`）

2つの数値のあまりを求める演算子です。

```js
8 % 3; // => 2
```

### [ES2016] べき乗演算子 （`**`） 

2つの数値のべき乗を求める演算子です。

```js
2 ** 4; // => 2*2*2*2
```

べき乗演算子は同じ動作をする`Math.pow`メソッドも存在しています。

```js
Math.pow(2, 4); // => 16
```

べき乗演算子はES2016で後から追加された演算子であるため、関数と演算子それぞれ存在しています。
他の二項演算子は演算子が先に存在していたため、`Math`には関数がありません。

### グループ演算子（`(`と`)`）

グループ演算子は複数の二項演算子が組み合わさった場合に、演算子の優先順序を明示することができる演算子です。

たとえば、次のようにグループ演算子で囲んだ部分が最初に処理されるため、処理結果も変化します。

```js
var a = 1;
var b = 2;
var c = 3;
a + b * c; // 7
(a + b) * c; // => 9
```

[演算子の優先順序][]は仕様で定義されていますが、多様な演算子が出てきた場合に見分けるのは難しいです。
そのため、グループ演算子を使い優先順序を明示することが読みやすいコードへとつながります。

次のようなグループを演算子を使わずに書いたコードを見てみましょう。

```js
1 * 2 + 3 * 4; // => 14
```

ひとつの式にオペランドが4つ以上出てくると読みにくくなります。
このような場合にはグループ演算子を使い、結合順を明示して書くようにしましょう。

```js
(1 * 2) + (3 * 4); // => 14
```

## 単項演算子（算術）

単項演算子は、1つのオペランド受け取り処理する演算子です。

### 単項プラス演算子（`+`）

単項演算子の`+`はオペランドを数値に変換します。

明示的に`+数値`のように数値に対して、単行プラス演算子を付けるケースはほぼ無いでしょう。

```js
+1; // => 1
```

また、単項プラス演算子は、数値以外も数値へと変換します。

次の例では、数字を数値へ変換しています。
一方、数値に変換できない文字列などは`NaN`という特殊な値へと変換されます。

```js
+"1"; // => 1
+"文字列"; // => NaN
```

`NaN`は"Not-a-Number"の略称で、数値ではないがNumber型の値を表現しています。
`NaN`はどの値とも（NaN自身に対しても）一致しない特性があり、`isNaN`関数を使うことで`NaN`の判定を行えます。

```js
typeof NaN; // => "number"
isNaN(NaN); // => true
```

TODO: 単項演算子の`+`は文字列から数値への変換には利用してはいけません。
`parseInt`を使うべきです。

### 単項マイナス演算子 （`-`）

単項マイナス演算子はマイナスの数値を記述する場合に利用します。

例えば、マイナスの1という数値は `-1` と書くことができるのは、単項マイナス演算子を利用しているからです。

```js
-1; // => -1
```

また、単項マイナス演算子はマイナスの数値を反転することができます。
そのため、"マイナスのマイナスの数値"はプラスの数値となります。

```js
-(-1); // => 1
```

単項マイナス演算子も文字列などを数値へ変換します。
単項プラス演算子と同様で、この挙動を使った数値への変換は行うべきではありません。

```js
-"1"; // => -1
-"文字列"; // => NaN
```

### インクリメント （`++`）

```js
var num = 1;
num++; // => 1
console.log(num); // => 2
++num; // => 3
console.log(num); // => 3
```

### デクリメント （`--`）

```js
var num = 42;
num--; // => 42
console.log(num); // => 41
--num; // => 40
console.log(num); // => 40
```

## 比較演算子

### 等しい （`==`）

```js
1 == 1; // => true
1 == "1"; // => true
"str" == "str"; // => true
"JavaScript" == "ECMAScript"; // => false
true == true;// => true
```

`NaN`はNot a Numberで特殊。

```js
NaN == NaN; // => false
NaN != NaN; // => true
Number.isNaN(Nan);// => true
```

### 等しくない （`!=`）

```js
1 != 1; // => false
1 != "1"; // => false
"str" != "str"; // => false
"JavaScript" != "ECMAScript"; // => true
true != true;// => false
```

### 厳密に等しい （`===`）

**型変換**おきないため安全。

```js
1 === 1; // => true
1 === "1"; // => false
```

### 厳密に等しくない （`!==`）

```js
1 !== 1; // => false
1 !== "1"; // => true
```

### より大きい （`>`）

```js
42 > 21; // => true
42 > 42; // => false
```

### 以上 （`>=`）

```js
42 >= 42; // => true
42 > 42 || 42 == 42; // => true
```

### より小さい （`<`）

```js
21 < 42;// => true
42 < 42; // => false
```

### 以下 （`<=`）

```js
42 <= 42; // => true
42 < 42 || 42 == 42;// => true
```

## ビット演算子

### ビット論理積 （`&`）

```js
15     & 9;      // => 9
0b1111 & 0b1001; // => 0b1001
// ^__^     ^__^
0b1111 
& 0b1001; // => 0b1001
//  ^__^
```

### ビット論理和 （`|`）

```js
15     | 9;      // => 15
0b1111 | 0b1001; // => 0b1111
// ^^^^     ^^^^
0b1111 
| 0b1001; // => 0b1111
//  ^^^^
```

### ビット排他的論理和 （`^`）

```js
15     ^ 9;      // => 6
0b1111 ^ 0b1001; // => 0b0110
// _^^_     _^^_
0b1111 
^ 0b1001; // => 0b0110
//  _^^_
```

### ビット否定 （`~`）

```js
~15; // => -16
~0b1111; // => -0b10000
// ^^^^
~-1; // => 0
```

JavaScriptの`indexOf`は見つからなかった場合に-1を返す。
これを利用して `~-1` => 0、他がマイナスになることを利用して判定する人がいる。
ややこしいので使わなくてよい。

```js
~0; // => -1
~1; // => -2
```

### 左シフト（`<<`）

```js
0b1111 === 15;// => true
0b1111 << 2; // => 0b111100
```

### 右シフト（`>>`）


```js
0b1111 === 15;// => true
0b1111 >> 2; // => 0b11
-9 >> 2; // => -0b11
```
  

### ゼロ埋め右シフト（`>>>`）

```js
-9;        //    0b11111111111111111111111111110111
//              |              32bit             |
//              |                               ^^ 捨てられる
(-9) >>> 2;  // => 0b00111111111111111111111111111101
//                        ^^<-ゼロ埋め          -> 2個シフト
```
  
## 代入演算子（`=`）

```js
var version = 2015;
version = 2016;
```

## 条件（三項）演算子（`?`と`:`）

if文的な。

```js
var valueAorB = true ? "A" : "B";
console.log(value); // => "A";
var valueAorB = false ? "A" : "B";
console.log(value); // => "B";
```

## 論理演算子

### AND（`&&`）

```js
true && false; // => false
false && true; // => false
```

ユースケース。

```js
var value = "str";
if (typeof value === "string" && value === "str") {
    console.log(`${value} is string value`);
}
```

### OR（`||`）

```js
true || false; // => true
false || true; // => true
```

ユースケースとしてはデフォルト引数。

```js
function doSomething(arg) {
    var actualValue = arg || true;
    return actualValue;
}
doSomething(); // => true
actualValue("value"); // => "value"
```

## 文字列演算子（`+`）

文字列の結合。

```js
var value = "文字列" + "結合";
console.log(value); // => "文字列結合"
```

```js
var value = "文字列";
value += "結合";
console.log(value); // => "文字列結合"
```

## コンマ演算子（`,`）

```js
var a, b, c;
```

```js
var obj = {
    getThis() {
        return this;
    }
};
(0, obj.getThis)(); // => undefined
```


- [Why is (0,obj.prop)() not a method call?](http://www.2ality.com/2015/12/references.html "Why is (0,obj.prop)() not a method call?")

## 単項演算子（特殊）

### delete演算子

オブジェクトのプロパティ または 配列の指定した添字を削除する。

```js
var obj = { key: "value" };
delete obj.key;
console.log(obj.key); // => undefined
```

```js
var array = [5, 10];
delete array[0];
console.log(array[0]); // => undefined
console.log(array[1]); // => 10
```

変数を削除する演算子ではない。

<!-- textlint-disable -->

```js
var foo = "val";
delete foo; // => Error
```

<!-- textlint-enable -->

### typeof演算子

説明済み。プリミティブとオブジェクトの判定について。

```js
typeof "value"; // => "string"
typeof 42; // => "number"
```

### void演算子

`undefined`を返す特性を利用した圧縮やブックマークレットの仕組みに使われている。

```js
void 0;// => undefined
```

## 関係演算子

### in演算子

for...in文と同じ。

```js
var object = { "key": "value" };
"key" in object; // => true
Reflect.has(object, "key"); // => true
object.hasOwnProperty("key"); // => true
```


[演算子の優先順序]: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table "演算子の優先順位 - JavaScript | MDN"
