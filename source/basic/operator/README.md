---
author: azu
---

# 演算子

演算子はよく利用する計算を関数やメソッドではなく、記号として表現したものです。
たとえば、足し算を行う `+` も演算子の一種で、演算子には多くの種類があります。

演算子は記号単独ではなく、演算の対象が必要になります。
演算子の対象のことを被演算子（オペランド）と呼ぶ。

次の`1 + 2`という`+`演算子について見てみます。

```js
1 + 2;
```

この演算は、次のような1つの演算子に対して、2つのオペランドを前後に置いています。
このような2つのオペランドを取る演算子を**二項演算子**と呼びます。

```
オペランド1 演算子 オペランド2
```

また、1つの演算子に対して1つのオペランドをとるものもあります。
たとえば、次のような数値をインクリメントする`++`演算子は、前後どちらかにオペランドを置きます。

```js
var num = 1;
num++;
// または
++num;
```

このような1つのオペランドを取る演算子を**単項演算子**と呼びます。
単項演算子と二項演算子で同じ記号を使うことがあり、そのために呼び方を変えています。

多くのプログラミング言語では同じような演算子を持っています。
この節は、分からない記号が出てきたら確認する意味で読むとよいでしょう。

しかし、JavaScriptでは比較演算子において、暗黙的な型変換が行われることによる問題があります。
そのため、演算子をひととおり見た後に、暗黙的な型変換がと明示的な型変換について学んでいきます。

## 二項演算子

四則演算など基本的な二項演算子を見ていきます。


### プラス （`+`）

2つの数値を加算する演算子です。

```js
1 + 1; // => 2
```

### マイナス （`-`）

2つの数値を減算する演算子です。

```js
42 - 1; // => 41
```

### 乗算 （`*`）

2つの数値を乗算する演算子です。

```js
2 * 8; // => 16
```

### 除算 （`/`）

2つの数値を除算する演算子です。

```js
8 / 2; // => 4
```

### 剰余 （`%`）

2つの数値のあまりを求める演算子です。

```js
8 % 3; // => 2
```

### [ES2016] べき乗演算子 （`**`） 

2つの数値のべき乗を求める演算子です。

```js
2 ** 4; // => 2*2*2*2
```

べき乗演算子は同じ動作をする`Math.pow`メソッドも存在しています。

```js
Math.pow(2, 4); // => 16
```

べき乗演算子はES2016で後から追加された演算子であるため、関数と演算子それぞれ存在しています。
他の二項演算子は演算子が先に存在していたため、`Math`には関数がありません。

### グループ演算子（`(`と`)`）

グループ演算子は複数の二項演算子が組み合わさった場合に、演算子の優先順序を明示することができる演算子です。

たとえば、次のようにグループ演算子で囲んだ部分が最初に処理されるため、処理結果も変化します。

```js
var a = 1;
var b = 2;
var c = 3;
a + b * c; // 7
(a + b) * c; // => 9
```

[演算子の優先順序][]は仕様で定義されていますが、多様な演算子が出てきた場合に見分けるのは難しいです。
そのため、グループ演算子を使い優先順序を明示することが読みやすいコードへとつながります。

次のようなグループを演算子を使わずに書いたコードを見てみましょう。

```js
1 * 2 + 3 * 4; // => 14
```

ひとつの式にオペランドが4つ以上出てくると読みにくくなります。
このような場合にはグループ演算子を使い、結合順を明示して書くようにしましょう。

```js
(1 * 2) + (3 * 4); // => 14
```

## 単項演算子（算術）

単項演算子は、1つのオペランド受け取り処理する演算子です。

### 単項プラス演算子（`+`）

単項演算子の`+`はオペランドを数値に変換します。

明示的に`+数値`のように数値に対して、単行プラス演算子を付けるケースはほぼ無いでしょう。

```js
+1; // => 1
```

また、単項プラス演算子は、数値以外も数値へと変換します。

次の例では、数字を数値へ変換しています。
一方、数値に変換できない文字列などは`NaN`という特殊な値へと変換されます。

```js
+"1"; // => 1
+"文字列"; // => NaN
```

`NaN`は"Not-a-Number"の略称で、数値ではないがNumber型の値を表現しています。
`NaN`はどの値とも（NaN自身に対しても）一致しない特性があり、`isNaN`関数を使うことで`NaN`の判定を行えます。

```js
typeof NaN; // => "number"
isNaN(NaN); // => true
```

TODO: 単項演算子の`+`は文字列から数値への変換には利用してはいけません。
`parseInt`を使うべきです。

### 単項マイナス演算子 （`-`）

単項マイナス演算子はマイナスの数値を記述する場合に利用します。

たとえば、マイナスの1という数値は `-1` と書くことができるのは、単項マイナス演算子を利用しているからです。

```js
-1; // => -1
```

また、単項マイナス演算子はマイナスの数値を反転することができます。
そのため、"マイナスのマイナスの数値"はプラスの数値となります。

```js
-(-1); // => 1
```

単項マイナス演算子も文字列などを数値へ変換します。
単項プラス演算子と同様で、この挙動を使った数値への変換を行うべきではありません。

```js
-"1"; // => -1
-"文字列"; // => NaN
```

### インクリメント （`++`）

インクリメント演算子は、オペランドの数値に`+1`する演算子です。
次のように、プラス演算子（`+`）と代入演算子（`=`）と同じことを、インクリメント演算子（`++`）で表現できます。

```js
var num = 1;
num++;
// 同じ
num = num + 1;
```

オペランドの前後のどちらかに置くことができますが、それぞれで評価の順番が異なります。

後置インクリメント演算子（`num++`）は、次のような順で処理が行われます。
そのため、`num++`が返す値は`+1`する前の値となります。

1. `num`が評価
2. `num`に対して`+1`する

一方、前置インクリメント演算子（`++num`）は、次のような順で処理が行われます。
そのため、`++num`が返す値は`+1`した後の値となります。

```js
var num = 1;
num++; // => 1
console.log(num); // => 2
++num; // => 3
console.log(num); // => 3
```

### デクリメント （`--`）

デクリメント演算子は、オペランドの数値に`-1`する演算子です。

インクリメント演算子と同様に、オペランドの前後のどちらかに置くことができます。

```js
var num = 42;
num--; // => 42
console.log(num); // => 41
--num; // => 40
console.log(num); // => 40
```

## 比較演算子

比較演算子はオペランド同士の値を比較し、真偽値を返す演算子です。

### 厳密等価演算子（`===`）

厳密等価演算子は、左右の2つのオペランドを比較します。
同じ型で同じ値である場合に、`true`を返します。

```js
1 === 1; // => true
1 === "1"; // => false
```

また、オペランドがどちらもオブジェクトである時は、
オブジェクトの参照が同じである場合に、`true`を返します。

```js
// {} は新しいオブジェクトを作成している
var objA = {}, objB = {};
objA === objB; // => false
// 同じ参照を比較している場合
objA === objA; // => true
```

### 厳密不等価演算子（`!==`）

厳密不等価演算子は、左右の2つのオペランドを比較します。
異なる型または異なる値である場合に、`true`を返します。

```js
1 !== 1; // => false
1 !== "1"; // => true
```


### 等価演算子 （`==`）

等価演算子（`==`）は、2つのオペランドを比較します。
同じ型のオペランドを比較する場合は、厳密等価演算子（`===`）と同じ処理を行います。

```js
1 == 1; // => true
"str" == "str"; // => true
"JavaScript" == "ECMAScript"; // => false
// オブジェクトは参照が一致しているならtrueを返す
// {} は新しいオブジェクトを作成している
var objA = {}, objB = {};
objA == objB; // => false
objA == objA; // => true
```

しかし、等価演算子（`==`）はオペランド同士が異なる型の値であった場合に、
同じ型となるように**暗黙的な変換**してから比較を行います。

そのため、次のような見た目からは、結果を予測できない挙動が多く存在します。

```js
// 文字列を数値に変換してから比較
1 == "1"; // => true
// "01"を数値にすると`1`となる
1 == "01"; // => true
// 真偽値を数値に変換してから比較
0 == false; // => true
// nullの比較はfalseを返す
0 == null; // => false
// nullとundefeinedの比較は常にtrueを返す
null  == undefined; // => true
```

意図しない挙動となることがあるため、暗黙的な変換が行われる等価演算子（`==`）を使うべきではありません。
代わりに、厳密等価演算子（`===`）を使い、異なる型を比較したい場合は明示的に型を合わせるべきです。

等価演算子（`==`）において許容される例外として、`null`と`undefined`の比較があります。
次のように、比較したいオペランドが `null` または `undefined` であることを判定したい場合に、
厳密等価演算子では2度比較する必要があります。

```js
var value = getValue();
if (value == null || value === undefined) {
    // valueがnullまたはundefeindである場合の処理
}
// == で書いた場合
if (value == null) {
    // valueがnullまたはundefeindである場合の処理
}
```

しかし、このようなケースにおいても仕組みを理解するまでは、
常に厳密等価演算子（`===`）を利用することを推奨します。

### 不等価演算子 （`!=`）

不等価演算子（`!=`）は、2つのオペランドを比較し、等しくないなら`true`を返します。

```js
1 != 1; // => false
"str" != "str"; // => false
"JavaScript" != "ECMAScript"; // => true
true != true;// => false
// オブジェクトは参照が一致していないならtrueを返す
var objA = {}, objB = {};
objA != objB; // => true
objA != objA; // => false
```

不等価演算子も、等価演算子（`==`）と同様に異なる型のオペランドを比較する際に、暗黙的な型変換を行ってから比較します。

```js
1 != "1"; // => false
0 != false; // => false
0 != null; // => true
null  == undefined; // => true
```

そのため、不等価演算子（`!=`）は、利用するべきではありません。
代わりに暗黙的な型変換を行わない厳密不等価演算子（`!==`）を利用します。

### 大なり演算子/より大きい （`>`）

大なり演算子は、左オペランドが右オペランドより大きいならば、`true`を返します。

```js
42 > 21; // => true
42 > 42; // => false
```

### 大なりイコール演算子/以上 （`>=`）

大なりイコール演算子は、左オペランドが右オペランドより大きいまたは等しいならば、`true`を返します。


```js
42 >= 42; // => true
42 > 42 || 42 === 42; // => true
```

### 小なり演算子/より小さい （`<`）

小なり演算子は、左オペランドが右オペランドより小さいならば、`true`を返します。

```js
21 < 42;// => true
42 < 42; // => false
```

### 小なりイコール演算子/以下 （`<=`）

小なりイコール演算子は、左オペランドが右オペランドより小さいまたは等しいならば、`true`を返します。

```js
42 <= 42; // => true
42 < 42 || 42 === 42;// => true
```

## ビット演算子

JavaScriptでは、数値は内部的にIEEE 754方式の浮動小数点数として表現されています。
（ [データ型とリテラル](../data-type/README.md)を参照）

ビット演算子はオペランドを符号付き32bit整数に変換してから演算します。
ビット演算子による演算結果は10進数の数値を返します。

たとえば、`9`という数値は符号付き32bit整数では次のように表現されます。

```js
0b0000000000000000000000000001001; // => 9
// Number#toStringメソッドを使うことで2進数表記の文字列を取得できる
(9).toString(2); // => "1001"
```

また、`-9`という数値は、ビッグエンディアンの2の補数形式で表現されるため、次のようになります。

```js
0b11111111111111111111111111110111; // => 4294967287
// ゼロ桁埋め右シフトをしてからNumber#toStringで2進数表記を取得できる
(-9 >>> 0).toString(2); // => "11111111111111111111111111110111"
```

### ビット論理積 （`&`）

論理積演算子（`&`）はビットごとの**AND**演算した結果を返します。

```js
15     & 9;      // => 9
0b1111 & 0b1001; // => 0b1001
// ^__^    ^__^
0b1111 
& 0b1001; // => 0b1001
//  ^__^
```

### ビット論理和 （`|`）

論理和演算子 （`|`）はビットごとの**OR**演算した結果を返します。

```js
15     | 9;      // => 15
0b1111 | 0b1001; // => 0b1111
//^^^^     ^__^
  0b1111 
| 0b1001; // => 0b1111
//  ^^^^
```

### ビット排他的論理和 （`^`）

排他的論理和演算子（`^`）はビットごとの**XOR**演算した結果を返します。

```js
15     ^ 9;      // => 6
0b1111 ^ 0b1001; // => 0b0110
// _^^_     _^^_
0b1111 
^ 0b1001; // => 0b0110
//  _^^_
```

### ビット否定 （`~`）

単項演算子の否定演算子（`~`）はオペランドを反転した値を返します。
これは1の補数と知られている値と同じものです。

```js
~15; // => -16
~0b1111; // => -0b10000
// ^^^^
```

否定演算子（`~`）はビット演算以外でも使われていることがあります。

JavaScriptの`String#indexOf(string)`は、文字列中にある`string`の位置を見つけて返すメソッドです。
この`indexOf`メソッドは、検索対象が見つからない場合に、`-1`を返します。

```js
var string = "森森本森森";
// 見つかった場合はindex値を返す
string.indexOf("本"); // => 2
// 見つからない場合は-1を返す
string.indexOf("火"); // => -1
```

否定演算子（`~`）は1の補数を返すため、`~(-1)`の`0`となります。

```js
~0; // => -1
~(-1); // => 0
```

JavaScriptでは`0`もif文では`false`として扱われます。
そのため、`~indexOfの結果`が`0`となることを利用して書くイディオムが一部では使われています。

```js
var string = "森森本森森";
if (string.indexOf("火") === -1) {
    // 見つからなかった場合の処理
}
// 否定演算子（`~`）で類似表現
if (~string.indexOf("火")) {
    // 見つからなかった場合の処理
}
```

このイディオムは文字列を検索した結果を真偽値で取得できれば不要となるケースが殆どです。
ES2015以降では`String#includes`で真偽値を取得できるため、分かりにくいだけのイディオムとなりつつあります。

```js
var string = "森森本森森";
// `String#includes`は"火"があるならtrueを返す
if (!string.includes("火")) {
    // 見つからなかった場合の処理
}
```

<!-- textlint-disable eslint -->

### 左シフト演算子（`<<`）

左シフト演算子は、`number`を`bit`の数だけ左へシフトします。
左にあふれたビットは破棄され、`0`のビットを右から詰めます。

```js
number << bit;
```

次のコードでは、`9`を2ビット分だけ左へシフトしています。

```js
     9 << 2; // => 36
0b1111 << 2; // => 0b111100
```

### 右シフト演算子（`>>`）

右シフト演算子は、`number`を`bit`の数だけ右へシフトします。
右にあふれたビットは破棄され、左端のビットのコピーを左から詰めます。

```js
number >> bit;
```

次のコードでは、`-9`を2ビット分だけ右へシフトしています。
左端のビットのコピーを使うため、常に符号は維持されます。

```js
(-9) >> 2; // => -3
0b11111111111111111111111111110111 >> 2; // => 0b11111111111111111111111111111101
```

### ゼロ埋め右シフト演算子（`>>>`）

ゼロ埋め右シフト演算子は、`number`を`bit`の数だけ右へシフトするのは右シフト演算子（`>>`）と同じです。
右にあふれたビットは破棄され、`0`のビットを左から詰めます。

次のコードでは、`-9`を2ビット分だけゼロ埋め右シフトしています。
左端のビットは`0`となるため、常に正の値となります。

```js
(-9) >>> 2; // => 1073741821
0b00111111111111111111111111111101 >>> 2; // => 0b00111111111111111111111111111101
```

<!-- textlint-enable eslint -->

## 代入演算子（`=`）

```js
var version = 2015;
version = 2016;
```

## 条件（三項）演算子（`?`と`:`）

if文的な。

```js
var valueAorB = true ? "A" : "B";
console.log(value); // => "A";
var valueAorB = false ? "A" : "B";
console.log(value); // => "B";
```

## 論理演算子

### AND（`&&`）

```js
true && false; // => false
false && true; // => false
```

ユースケース。

```js
var value = "str";
if (typeof value === "string" && value === "str") {
    console.log(`${value} is string value`);
}
```

### OR（`||`）

```js
true || false; // => true
false || true; // => true
```

ユースケースとしてはデフォルト引数。

```js
function doSomething(arg) {
    var actualValue = arg || true;
    return actualValue;
}
doSomething(); // => true
actualValue("value"); // => "value"
```

## 文字列演算子（`+`）

文字列の結合。

```js
var value = "文字列" + "結合";
console.log(value); // => "文字列結合"
```

```js
var value = "文字列";
value += "結合";
console.log(value); // => "文字列結合"
```

## コンマ演算子（`,`）

```js
var a, b, c;
```

```js
var obj = {
    getThis() {
        return this;
    }
};
(0, obj.getThis)(); // => undefined
```


- [Why is (0,obj.prop)() not a method call?](http://www.2ality.com/2015/12/references.html "Why is (0,obj.prop)() not a method call?")

## 単項演算子（特殊）

### delete演算子

オブジェクトのプロパティ または 配列の指定した添字を削除する。

```js
var obj = { key: "value" };
delete obj.key;
console.log(obj.key); // => undefined
```

```js
var array = [5, 10];
delete array[0];
console.log(array[0]); // => undefined
console.log(array[1]); // => 10
```

変数を削除する演算子ではない。

<!-- textlint-disable -->

```js
var foo = "val";
delete foo; // => Error
```

<!-- textlint-enable -->

### typeof演算子

説明済み。プリミティブとオブジェクトの判定について。

```js
typeof "value"; // => "string"
typeof 42; // => "number"
```

### void演算子

`undefined`を返す特性を利用した圧縮やブックマークレットの仕組みに使われている。

```js
void 0;// => undefined
```

## 関係演算子

### in演算子

for...in文と同じ。

```js
var object = { "key": "value" };
"key" in object; // => true
Reflect.has(object, "key"); // => true
object.hasOwnProperty("key"); // => true
```


[演算子の優先順序]: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table "演算子の優先順位 - JavaScript | MDN"
