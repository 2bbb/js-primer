---
author: azu
---

# 暗黙的な型変換

このセクションでは、明示的な型変換と暗黙的な型変換について学んでいきます。

[演算子][]のセクションにて、等価演算子において**暗黙的な型変換**による意図しない挙動について紹介しました。

> 等価演算子（`==`）はオペランド同士が異なる型の値であった場合に、
> 同じ型となるように**暗黙的な型変換**してから比較を行います。

次のような、数値と真偽値の加算の例を見てみましょう。
多くの言語では、数値と真偽値の加算は型エラーとなり、コンパイルエラーまたは実行時エラーとなります。
しかし、JavaScriptでは暗黙的な型変換が行われ、エラーなく処理されます。

この例では、真偽値の`true`が数値の`1`へと暗黙的に変換されてから加算処理行われます。

{{book.console}}
```js
// エラーとなって欲しい
// しかし、暗黙的な型変換が行われ、数値の加算として計算される
1 + true; // => 2
// 次のように暗黙的に変換されてから計算される
1 + 1; // => 2
```

JavaScriptでは、エラーが発生するのではなく、暗黙的な型変換が行われてしまうケースが多くあります。
暗黙的に変換が行われた場合、プログラムは例外を投げずに進むため、バグの発見が難しくなります。

そのため、暗黙的な型変換は避けるべき挙動であるといえます。

このセクションでは、次のことについてを学んでいきます。

- [ ] TODO: 言葉でまとめる
- 暗黙的な型変換とはどのようなものなのか
- 暗黙的ではない明示的な型変換の方法
- すべてが明示的な変換では解決しない

## 暗黙的な型変換

暗黙的な型変換とは次のことをいいます。

- ある処理において、その処理過程において行われる明示的ではない型変換のこと

具体的な例を見てみましょう。

次のコードでは、数値の`1`と文字列の`"2"`をプラス演算子で処理しています。
プラス演算子（`+`）は、数値の加算と文字列の結合を両方実行できるように多重定義されています。
このケースでは、JavaScriptは文字列の結合を優先する仕様となっています。
そのため、数値の`1`を文字列の`"1"`へ暗黙的に変換してから、文字列結合します。

{{book.console}}
```js
1 + "2"; // => "12"
// 演算過程で次のように変換される
"1" + "2"; // => "12"
```

もうひとつ、数値と文字列での暗黙的な型変換を見てみましょう。
次のコードでは、数値の`1`から文字列の`"2"`を減算しています。

JavaScriptには、文字列に関するマイナス演算子（`-`）の定義はありません。
そのため、マイナス演算子のある数値が優先されます。
これにより、文字列の`"2"`を数値の`2`へ暗黙的に変換してから、減算します。

{{book.console}}
```js
1 - "2"; // => -1
// 演算過程で次のように変換される
1 - 2; // => -1
```

2つの値までは、まだ結果の型を予想することができます。
しかし、3つ以上の値を扱う場合に結果を予測することができなくなります。

次のように3つ以上の値を演算する場合に、値の型が混ざっていると、
演算する順番によっても結果が異なります。

{{book.console}}
```js
var x = 1, y = "2", z = 3;
x + y + z; // => "123"
y + x + z; // => "213"
```

このように、処理の過程で処理の対象となる値の型によって、
自動的に変換されることを**暗黙的な型変換**と呼んでいます。

暗黙的な型変換では、結果の値の型はオペランドの型に依存しています。
それを避けるには、暗黙的ではない変換 ー つまり明示的な型変換をする必要があります。

## 明示的な型変換

### 数値 -> 文字列

- フォーマッター

数値から文字列へ明示的に変換する場合は、`String`コンストラクタ関数に値を渡せばよい。

```js
String(1); // => "1"
```

`String`コンストラクタは、数値以外にも色々な値を文字列へと変換することができます。

```js
String("str"); // => "str"
String(true); // => "true"
String(null); // => "null"
String(undefined); // => "undefined"
String(Symbol("シンボル")); // => "Symbol(シンボル)"
String([1, 2, 3]); // => "1,2,3"
String({ key: "value" }); // => "[object Object]"
String(function() {}); // 実装依存の結果
```

上記の結果からも分かるように`String`コンストラクタ関数での明示的な変換は、万能な方法ではありません。
真偽値、数値、文字列、undefined、null、シンボルのプリミティブ型の値に対して変換は見た目どおりの文字列を得ることができます。
しかし、プリミティブ型以外の値に対しては直感的な値を返しません。

また、配列には`Array#join`、オブジェクトには`JSON.stringify()`などより柔軟な文字列化をするメソッドが存在しています。
そのため、`String`コンストラクタ関数での明示的な変換は、あくまでプリミティブ型に対してのみに留めるべきです。

### シンボル -> 文字列

プラス演算子を文字列に利用した場合、文字列の結合を優先するようになっています。
「片方が文字列なら、もう片方のオペランドとは関係なく、結果は文字列となるのでは？」と考えるかもしれません。

```js
"文字列" + x; // 文字列となる？
```

しかし、ES2015で追加されたプリミティブ型であるシンボルを暗黙的に型変換することができません。
文字列結合演算子をシンボルに対して利用すると例外を投げるようになっています。
そのため、片方が文字列であるからと言ってプラス演算子の結果は必ず文字列になるとは限らないことが分かります。

{{book.console}}
```js
"文字列と" + Symbol("シンボルの説明"); // => Error
```

この問題も`String`コンストラクタ関数を使うことで、シンボルを文字列化することで解決できます。

{{book.console}}
```js
"文字列と" + String(Symbol("シンボルの説明")); // => "文字列とSymbol(シンボルの説明)"
```

### 文字列 -> 数値

文字列から数値に変換する典型的なケースとしてはユーザー入力から数字を受け取ることがあげられます。
ユーザー入力は文字列でしか受け取ることができないため、それを数値に変換してから利用する必要があります。

文字列から数値へ明示的に変換するには`Number`コンストラクタ関数が利用できます。

{{book.console}}
```js
// ユーザー入力を文字列として受け取る
var input = window.confirm("数字を入力してください");
// 文字列を数値に変換する
var number = Number(input);
console.log(typeof number); // => "number";
console.log(number); // 入力された文字列を数値に変換したもの
```

また、文字列から数字を取り出し変換する関数として`Number.parseInt`、`Number.parseFloat`も利用できます。
`Number.parseInt`は文字列から整数を取り出し、`Number.parseFloat`は文字列から浮動小数点数を取り出すことができます。
`Number.parseInt(文字列, 基数)`の第二引数には基数指定します。
たとえば、文字列をパースして10進数として数値を取り出したい場合は、第二引数に基数として`10`を指定します。

{{book.console}}
```js
// "1"をパースして10進数として取り出す
Number.parseInt("1", 10); // => 1;
// 余計な文字はパース時に無視して取り出す
Number.parseInt("42px", 10); // => 42
Number.parseInt("10.0", 10); // => 10
Number.parseFloat("1"); // => 1
Number.parseInt("42.0px"); // => 42.0
Number.parseFloat("10.0"); // => 10.0
```

しかし、ユーザーが数字を入力するとは限りません。
`Number`コンストラクタ関数、`Number.parseInt`、`Number.parseFloat`は、
数字以外の文字列を渡すと`NaN`（Not a Number）を返します。

{{book.console}}
```js
// 数字ではないため、数値へは変換できない
Number("文字列"); // => NaN
```

### [コラム] NaNはNot a NumberだけどNumber型

`NaN`はNot a Numberの略称で、特殊な性質をもつNumber型のデータです。
Number型と互換性のない性質のデータをNumber型へ変換した結果は`NaN`となります。

たとえば、オブジェクトは数値とは互換性の無いデータです。
そのため、オブジェクトを明示的に変換したとしても結果はNaNになります。

{{book.console}}
```js
Number({}); // => NaN
```

また、`NaN`は何と演算しても結果は`NaN`になる特殊な値です。
しかし、 `NaN`はNumber型の一種であるという名前と矛盾したデータに見えます。

{{book.console}}
```js
// NaNはnumber型
typeof NaN; // => "number"
```

加えてNaNの特殊な性質として、自分自身と一致しないという特徴があります。
この特徴を利用することで、ある値が`NaN`であるかを判定することもできます。

{{book.console}}
```js
function isNaN(x) {
    // NaNは自分自身と一致しない
    return x !== x;
}
isNaN(1); // => false
isNaN("str"); // => false
isNaN({}); // => false
isNaN([]); // => false
isNaN(NaN); // => true
```

同様の処理を行うメソッドとして`Number.isNaN(x)`があります。

{{book.console}}
```js
Number.isNaN(NaN); // => true
```

## 明示的な変換でも解決しないこと

先ほどの例からも分かるように、あらゆるケースが明示的な変換で解決できるわけではありません。
Number型と互換性がない値を数値にしても、`NaN`となってしまいます。
また、すべてのオブジェクトが情報の欠損なく文字列へ変換できるわけではありません。

- [ ] TODO: 基本的にJavaScriptの型変換は情報が減る方向の変換しかできない

そのため、明示的な変換をする前に、まず変換がそもそも必要なのかを考える必要があります。

また、同様に真偽値への変換は、型変換ではなくより正確な判定方法が存在するはずです。
たとえば、文字列が空文字なのかを判定したい場合を考えみましょう。
`""`（空文字）はfalsyな値であるため、明示的に`Boolean`コンストラクタ関数で変換することでも判定は可能です。
しかし、falsyな値は空文字以外にもあるため、明示的に変換したからといって正しく動くわけではありません。

{{book.console}}
```js
// 空文字かどうかを判定
function isEmptyString(string) {
    return !Boolean(string);
}
isEmptyString("");// => true
// falsyなら値なら、trueを返してしまっている
isEmptyString(0);// => true
// undefinedを渡した場合もtrueとなる
isEmptyString();// => true
```

空文字を判定する`isEmptyString`関数はもっと明確に書けるはずです。
空文字とは「String型で文字長が0の値」であると定義します。
次のように、より正確な判定を書くことができます。

{{book.console}}
```js
// 空文字かどうかを判定
function isEmptyString(string) {
    // String型でlengthが0の値が空文字
    return typeof string === "string" && string.length === 0;
}
isEmptyString("");// => true
// falsyな値でも正しく判定できる
isEmptyString(0);// => false
isEmptyString();// => false
```

`Boolean`を使った型変換は、楽をするための型変換であり、正確に真偽値を得るための方法ではありません。
そのため、型変換をする前にまず別の方法で解決できないかを考えてみましょう。

[演算子]: ../operator/README.md	"演算子のセクション"
