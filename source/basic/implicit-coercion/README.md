# 型変換

このセクションでは、明示的な型変換と暗黙的な型変換について学んでいきます。

[演算子][]のセクションにて、等価演算子において**暗黙的な型変換**による意図しない挙動について紹介しました。

> 等価演算子（`==`）はオペランド同士が異なる型の値であった場合に、
> 同じ型となるように**暗黙的な型変換**してから比較を行います。

多くの言語では、数値と真偽値の加算は型エラーとなり、コンパイルエラーまたは実行時エラーとなります。
しかし、JavaScriptでは暗黙的な型変換が行われ、エラーなく処理されます。

{{book.console}}
```js
// エラーとなって欲しい
// しかし、暗黙的な型変換が行われ、数値の加算として計算される
1 + true; // => 2
```

JavaScriptでは、このようなエラーではなく暗黙的な型変換が行われてしまうケースが多くあります。
プログラムは例外を投げずに進むため、バグの発見が難しくなります。

そのため、暗黙的な型変換は避けるべき挙動であるといえます。

このセクションでは、暗黙的な型変換とはどのようなものなのかを見ていきます。
また、暗黙的ではない明示的な型変換の方法について学んでいきます。

## 暗黙的な型変換

暗黙的な型変換とは次のことをいいます。

- ある処理において、その処理過程において行われる明示的ではない型変換のこと

具体的な例を見てみましょう。

次のコードでは、数値の`1`と文字列の`"2"`をプラス演算子で処理しています。
プラス演算子（`+`）は、数値の加算と文字列の結合を両方実行できるように多重定義されています。
このケースでは、JavaScriptは文字列の結合を優先する仕様となっています。
そのため、数値の`1`を文字列の`"1"`へ暗黙的に変換してから、文字列結合します。

{{book.console}}
```js
1 + "2"; // => "12"
// 演算過程で次のように変換される
"1" + "2"; // => "12"
```

もうひとつ、数値と文字列での暗黙的な型変換を見てみましょう。
次のコードでは、数値の`1`から文字列の`"2"`を減算しています。

JavaScriptには、文字列に関するマイナス演算子（`-`）の定義はありません。
そのため、マイナス演算子のある数値が優先されます。
これにより、文字列の`"2"`を数値の`2`へ暗黙的に変換してから、減算します。

{{book.console}}
```js
1 - "2"; // => -1
// 演算過程で次のように変換される
1 - 2; // => -1
```

2つの値までは、まだ結果の型を予想することができます。
しかし、3つ以上の値を扱う場合に結果を予測することができなくなります。

次のように3つ以上の値を演算する場合に、値の型が混ざっていると、
演算する順番によっても結果が異なります。

{{book.console}}
```js
var x = 1, y = "2", z = 3;
x + y + z; // => "123"
y + x + z; // => "213"
```

このように、処理の過程で処理の対象となる値の型によって、
自動的に変換されることを**暗黙的な型変換**と呼んでいます。

暗黙的な型変換では、結果の値の型はオペランド次第となる場合がることが分かります。
それを避けるには、暗黙的ではない変換 ー つまり明示的な型変換をする必要があります。

## 明示的な型変換

### 数値 -> 文字列

- フォーマッター

数値から文字列へ明示的に変換する倍は、`String`コンストラクタ関数に値を渡せば良い。

```js
String(1); // => "1"
```

`String`コンストラクタは、数値以外にも色々な値を文字列へと変換することができます。

```js
String("str"); // => "str"
String(true); // => "true"
String(null); // => "null"
String(undefined); // => "undefined"
String([1, 2, 3]); // => "1,2,3"
String({ key: "value" }); // => "[object Object]"
String(function(){}); // 実装依存の結果
```

上記の結果からも分かるように`String`コンストラクタ関数での明示的な変換は、万能な方法でありません。
真偽値、数値、文字列、undefined、null、シンボル以外の値に対して変換を行った場合、直感的な値が返されるワケではありません。

また、配列には`Array#join`、オブジェクトには`JSON.stringify()`などより適切な文字列化のメソッドが存在しています。
そのため、`String`コンストラクタ関数での明示的な変換は、あくまでプリミティブなデータ型に対してのみに留めるべきです。

### Symbol -> 文字列

### 文字列 -> 数値

- ユーザー入力

```js
// ユーザー入力を文字列として受け取る
var input = window.confirm("数字を入力してください");
// 文字列を数値に変換する
var number = Number(input);
console.log(typeof number); // => "number";
console.log(number); // 入力された文字列を数値に変換したもの
```

しかし、ユーザーが数字を入力するとは限りません。
`Number`コンストラクタ関数では、数字以外の文字列を渡すと`NaN`（Not a Number）を返します。

### NaN


[演算子]: ../operator/README.md "演算子のセクション"
